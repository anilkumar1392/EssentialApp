Learning outcomes in the Main module
Breaking responsibilities into multiple protocols (Interface Segregation Principle) to achieve flexible, composable and modular components.
Combining Xcode projects into a workspace and embedding frameworks to compose modules into a running iOS app.
Testing component behavior with the Stub test-double
Creating a flexible and modular strategy for loading data from remote with fallback logic without altering the services or the clients (Open/Closed Principle).
Composing objects that share a common interface with the Composite Design Pattern
Isolating side-effects to create simple, testable, and composable operations (Command-Query Separation Principle).
Using the Decorator Design Pattern to intercept and inject side-effects in the system composition, supporting single-purpose, testable, and modular components.
Using the Decorator Design Pattern to extend the behavior of a component without altering it (Open/Closed Principle).
Validating your app’s acceptance criteria with high-level UI tests.
Replacing and controlling flow logic and state in black-box UI tests.
Utilizing conditional compilation directives to safeguard your app from debug- and test-specific details.
Subclassing and extending components to remove conditional logic resulting in clean, decoupled, maintainable, and testable components.
Validating acceptance criteria with Integration Tests.
Replacing UI Tests with significantly faster and thorough Integration Tests.
What’s a Composition Root
Where’s the Composition Root in iOS apps
How to test components of the Composition Root
Simulating app launch and state transitions during tests
Testing methods you cannot invoke
Validating the app’s UI with Snapshot Testing
Supporting Dark Mode
Rendering views without running the app
Fixing bugs and preventing regressions following the TDD process
UITableViewCell reuse cycle
Invalidating work based on UITableViewDelegate events
Enforcing UITableView delegate events in Integration Tests
Horizontal modular slicing by layers
Vertical modular slicing by features
Organizing the codebase into independent frameworks and projects
Differences and Relations between Continuous Integration, Delivery, and Deployment
Guidelines for uploading builds to App Store Connect
Deploying builds to App Store Connect manually
Deploying builds to App Store Connect automatically with a Continuous Delivery pipeline
Correlations between SOLID components, Design Patterns, and Universal Abstractions from Category Theory
Using Combine to compose your application in the Composition Root
Future, Deferred, and AnyPublisher publishers
map, handleEvents, catch, eraseToAnyPublisher, sink, and receive(on:) operators
Cancellable
